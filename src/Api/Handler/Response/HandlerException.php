<?php
/**
 * B2W Digital - Companhia Digital
 *
 * Do not edit this file if you want to update this SDK for future new versions.
 * For support please contact the e-mail bellow:
 *
 * sdk@e-smart.com.br
 *
 * @category  SkuHub
 * @package   SkuHub
 *
 * @copyright Copyright (c) 2018 B2W Digital - BSeller Platform. (http://www.bseller.com.br).
 *
 * @author    Tiago Sampaio <tiago.sampaio@e-smart.com.br>
 */

namespace SkyHub\Api\Handler\Response;

use Exception;
use GuzzleHttp\Stream\CachingStream;

class HandlerException extends HandlerAbstract implements HandlerInterfaceException
{

    /** @var Exception */
    protected $exception = null;

    protected $content = '';


    /**
     * HandlerException constructor.
     *
     * @param Exception $exception
     */
    public function __construct(Exception $exception)
    {
        $this->exception = $exception;
    }


    /**
     * @return string
     */
    public function message()
    {
        if ($body = $this->body()) {
            return $body;
        }

        return $this->exception->getMessage();
    }


    /**
     * @return string
     */
    public function file()
    {
        return $this->exception->getFile();
    }


    /**
     * @return int|mixed
     */
    public function code()
    {
        return $this->exception->getCode();
    }


    /**
     * @return int
     */
    public function line()
    {
        return $this->exception->getLine();
    }


    /**
     * @return string
     */
    public function traceAsString()
    {
        return $this->exception->getTraceAsString();
    }


    /**
     * @return array
     */
    public function trace()
    {
        return $this->exception->getTrace();
    }

    /**
     * @return bool|\GuzzleHttp\Message\Request
     */
    public function request()
    {
        if (!method_exists($this->exception, 'getRequest')) {
            return false;
        }

        $request = $this->exception->getRequest();
        if (!($request instanceof \GuzzleHttp\Message\Request)) {
            return false;
        }

        return $request;
    }

    /**
     * @return bool|\GuzzleHttp\Message\Response
     */
    public function response()
    {
        if (!method_exists($this->exception, 'getResponse')) {
            return false;
        }

        $response = $this->exception->getResponse();
        if (!($response instanceof \GuzzleHttp\Message\Response)) {
            return false;
        }

        return $response;
    }

    /**
     * @return bool|\GuzzleHttp\Stream\StreamInterface|string
     */
    public function body()
    {
        if (!$this->response()) {
            return false;
        }

        if (!method_exists($this->response(), 'getBody')) {
            return false;
        }

        $body = $this->response()->getBody();
        if (!($body instanceof \GuzzleHttp\Stream\Stream)) {
            return false;
        }

        $body = $this->getErrors($body);

        if (!$body && !empty($this->content)) {
            return $this->content;
        }

        return $body;
    }

    /**
     * @param \GuzzleHttp\Stream\StreamInterface $stream
     * @return bool|string
     */
    public function readStream(\GuzzleHttp\Stream\StreamInterface $stream)
    {
        try {
            $stream = new CachingStream($stream);
            return $stream->read(4096);
        } catch (\Exception $e) {

        }

        return false;
    }

    /**
     * @param \GuzzleHttp\Stream\StreamInterface $stream
     * @return bool|string
     */
    public function getErrors(\GuzzleHttp\Stream\StreamInterface $stream)
    {
        $content = $this->readStream($stream);
        $error = $this->extractError($content);
        if (empty($error) && !empty($this->content)) {
            return $this->content;
        }

        $this->content = $error;
        return $this->content;
    }

    /**
     * @param $jsonContent
     * @return bool|string
     */
    public function extractError($jsonContent)
    {
        if (!($content = json_decode($jsonContent, true))) {
            return false;
        }

        $errors = array();
        foreach ($content as $error) {
            if (empty($error)) {
                continue;
            }

            $errors[] = (string)$error;
        }

        return implode('<br/>', $errors);
    }

    /**
     * @return bool
     */
    public function success()
    {
        return false;
    }


    /**
     * @return bool
     */
    public function exception()
    {
        return true;
    }


    /**
     * @return bool
     */
    public function invalid()
    {
        return false;
    }


    /**
     * @return array
     */
    public function export()
    {
        return [
            'message' => $this->message(),
            'file'    => $this->file(),
            'code'    => $this->code(),
            'line'    => $this->line(),
            'trace'   => $this->traceAsString(),
        ];
    }
}
